<!DOCTYPE html>
<html>
<head>
  <title>Calendar</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="calendar-styles.css">
</head>
<body>
  <div class="page-container">
    <div class="header-area">
      <a href="Index.html">
        <button>Back to Index</button>
      </a>

      
    </div>
    <div class="main-calendar-container">
      
      <div id="calendarContainer">
        <!-- Calendar will be generated here -->
         
      </div>

      <div id="infoPanel">
        <h2>Information</h2>
        <p>Details about selected dates or tasks will appear here.</p>
      </div>
    </div>

    <!-- The Modal -->
    <div id="addTaskModal" class="modal">

      <!-- Modal content -->
      <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Add Task</h2>
        <!-- Task form elements will go here later -->
        <p>Task details form will appear here.</p>

        <form id="addTaskForm">
          <div>
            <label for="taskDescription">Task Description:</label><br>
            <input type="text" id="taskDescription" name="taskDescription" required><br><br>
          </div>
          <button type="submit" id="startSelectionButton">Start Selecting Date(s)</button>
        </form>
      </div>

    </div>
  </div>

  <!-- Add the Done Selecting button here -->
  <button id="doneSelectingButton" style="display: none;">Done Selecting</button>

  <script>
    const calendarContainer = document.getElementById('calendarContainer');

    // Declare variables globally, but assign elements inside DOMContentLoaded
    let modal = null;
    let openModalButton = null;
    let closeButton = null;
    let doneSelectingButton = null;
    let taskDescriptionInput = null; // Declare globally

    // Month names array (moved to global scope)
    const monthNames = ["January", "February", "March", "April", "May", "June",
                          "July", "August", "September", "October", "November", "December"];
    const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]; // Keep dayNames here too

    // Variable to store tasks (using a simple array for now, will need more structure for weekly tasks)
    let tasks = JSON.parse(localStorage.getItem('calendarTasks')) || [];

    // Variable to store the description of the task being added during selection mode
    let taskDescriptionToSave = '';
    // Variable to track if we are in selection mode
    let isSelectingDate = false;

    function generateCalendar() {
      const today = new Date();
      const year = today.getFullYear();
      const month = today.getMonth(); // 0-indexed

      const firstDayOfMonth = new Date(year, month, 1);
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      // Get the day of the week for the first day (0 for Sunday, 6 for Saturday)
      const startingDayOfWeek = firstDayOfMonth.getDay();

      // Wrap button and title in a div with class calendar-header
      let calendarHTML = '<div class="calendar-header">';
      calendarHTML += '<button id="openAddTaskModal">Add Task</button>';
      calendarHTML += `<h2>${monthNames[month]} ${year}</h2>`;
      calendarHTML += '</div>'; // Close calendar-header div

      calendarHTML += '<div class="calendar-grid">';

      // Add day names row
      dayNames.forEach(day => {
        calendarHTML += `<div class="day-name">${day}</div>`;
      });

      // Add empty divs for days before the first day of the month
      for (let i = 0; i < startingDayOfWeek; i++) {
        calendarHTML += '<div class="empty-day"></div>';
      }

      // Add days of the month
      for (let day = 1; day <= daysInMonth; day++) {
        const currentDate = new Date(year, month, day);
        const isToday = currentDate.toDateString() === today.toDateString();
        let dayClass = isToday ? 'calendar-day current-day' : 'calendar-day';

        // Find tasks for the current day
        const tasksForDay = tasks.filter(task => {
            const taskDate = new Date(task.date);
            if (task.type === 'one-time') {
                // For one-time tasks, check if the task date is the same as the current calendar day
                return taskDate.toDateString() === currentDate.toDateString();
            } else if (task.type === 'weekly') {
                // For weekly tasks, check if the stored day of the week matches the current day of the week
                // AND if the task's start date is on or before the current date
                return task.dayOfWeek === currentDate.getDay() && taskDate <= currentDate;
            }
            return false; // Should not happen
        });

        let taskIndicatorHTML = '';
        if (tasksForDay.length > 0) {
            taskIndicatorHTML = '<div class="task-indicator"></div>'; // Simple indicator for now
            dayClass += ' has-tasks'; // Add a class to style days with tasks
        }

        calendarHTML += `<div class="${dayClass}">${day}${taskIndicatorHTML}</div>`;
      }

      calendarHTML += '</div>';

      calendarContainer.innerHTML = calendarHTML;

      // Add event listeners after the calendar HTML is rendered
      // The addCalendarEventListeners now only adds permanent delegation listeners.
      // Visual state (highlighting) is managed by enter/exitSelectionMode.
      addCalendarEventListeners();
    }

    // New function to add event listeners to dynamically created calendar elements
    // These listeners use event delegation and are permanent.
    function addCalendarEventListeners() {
      // Add click listeners to calendar days and weekday names (using event delegation)
      // const calendarDays = calendarContainer.querySelectorAll('.calendar-day'); // Not needed for event delegation
      const infoPanelTitle = document.querySelector('#infoPanel h2');

      // Variable to keep track of the currently selected day element
      // let selectedDayElement = null; // This state is more for info panel and less relevant for adding now

      // After regenerating calendar, if in selection mode, re-apply highlighting - Removed, handled by explicit state changes
      // if (isSelectingDate) {
      //     document.querySelectorAll('.calendar-day:not(.empty-day), .day-name').forEach(element => {
      //         element.classList.add('selectable-day');
      //     });
      //     // Ensure the done button is visible if in selection mode
      //     if (doneSelectingButton) doneSelectingButton.style.display = 'block';
      // }

      // Use event delegation for calendar days
      calendarContainer.addEventListener('click', (event) => {
          const dayElement = event.target.closest('.calendar-day');

          // Handle existing info panel logic only if NOT in selection mode
          if (dayElement && !dayElement.classList.contains('empty-day') && !isSelectingDate) {
              // Find the actual calendar-day element if a child was clicked
              const clickedCalendarDay = event.target.closest('.calendar-day');

               // Remove the 'selected-day' class from the previously selected day, if any
              const previouslySelectedDayElement = calendarContainer.querySelector('.calendar-day.selected-day');
              if (previouslySelectedDayElement) {
                previouslySelectedDayElement.classList.remove('selected-day');
              }

              // Add the 'selected-day' class to the clicked day
              if (clickedCalendarDay) {
                 clickedCalendarDay.classList.add('selected-day');

                 const day = parseInt(clickedCalendarDay.textContent);
                 // Get the year and month from the generated calendar title
                 const [monthName, year] = calendarContainer.querySelector('h2').textContent.split(' ');
                 const month = monthNames.indexOf(monthName);
                 const clickedDate = new Date(parseInt(year), month, day);

                 const options = { year: 'numeric', month: 'long', day: 'numeric' };
                 if (infoPanelTitle) infoPanelTitle.textContent = clickedDate.toLocaleDateString(undefined, options);

                 // Clear previous task list and add a heading
                 const infoPanel = document.getElementById('infoPanel');
                 let tasksListHTML = '';

                 // Find tasks for the clicked day
                 const tasksForClickedDay = tasks.filter(task => {
                     const taskDate = new Date(task.date);
                     if (task.type === 'one-time') {
                         return taskDate.toDateString() === clickedDate.toDateString();
                     } else if (task.type === 'weekly') {
                         // For weekly tasks, check if the stored day of the week matches
                         // and the task's start date is on or before the clicked date
                          return task.dayOfWeek === clickedDate.getDay() && taskDate <= clickedDate;
                     }
                     return false;
                 });

                 if (tasksForClickedDay.length > 0) {
                     tasksListHTML += '<h3>Tasks:</h3><ul>';
                     tasksForClickedDay.forEach(task => {
                         tasksListHTML += `<li>${task.description} (${task.type})</li>`;
                     });
                     tasksListHTML += '</ul>';
                 } else {
                     tasksListHTML += '<p>No tasks for this day.</p>';
                 }

                 // Update the info panel content (keeping the title)
                 if (infoPanel) {
                     // Assuming the H2 is the first child of infoPanel
                     while (infoPanel.children.length > 1) {
                       infoPanel.removeChild(infoPanel.lastChild);
                     }
                     infoPanel.innerHTML += tasksListHTML;
                 }
              }
            } // End of NOT in selection mode block

            // Handle task saving if in selection mode and a day is clicked
            if (isSelectingDate && dayElement && !dayElement.classList.contains('empty-day')) {
                 // Save as a one-time task
                const day = parseInt(dayElement.textContent);
                const [monthName, year] = calendarContainer.querySelector('h2').textContent.split(' ');
                const month = monthNames.indexOf(monthName);
                const selectedDate = new Date(parseInt(year), month, day);

                const newTask = {
                  description: taskDescriptionToSave,
                  type: 'one-time',
                  date: selectedDate.toISOString()
                };

                tasks.push(newTask);
                saveCalendarTasks(); // Save and regenerate calendar

                // Optional: Provide feedback to the user
                // The saveCalendarTasks call regenerates, so add feedback after a short delay
                 setTimeout(() => {
                     // Recalculate startingDayOfWeek here for feedback highlighting
                     // Get year and month from the calendar title, not current date
                     const calendarTitle = calendarContainer.querySelector('h2').textContent.split(' ');
                     const currentYear = parseInt(calendarTitle[1]);
                     const currentMonth = monthNames.indexOf(calendarTitle[0]);
                     const firstDayOfCurrentMonth = new Date(currentYear, currentMonth, 1);
                     const startingDayOfWeek = firstDayOfCurrentMonth.getDay();

                     // Corrected nth-child calculation: 7 day names + starting empty days + the day of the month
                     const dayOfMonth = parseInt(dayElement.textContent);
                     const nthChildIndex = 7 + startingDayOfWeek + dayOfMonth;

                     const updatedDayElement = calendarContainer.querySelector('.calendar-grid .calendar-day:nth-child(' + nthChildIndex + ')');
                     if (updatedDayElement) {
                        updatedDayElement.classList.add('task-added-feedback'); // Add a class for temporary feedback
                        setTimeout(() => {
                            updatedDayElement.classList.remove('task-added-feedback');
                        }, 500); // Remove class after 500ms
                     }
                 }, 50); // Small delay to allow DOM update

                // Keep selection mode active, do NOT reset state or UI here
            }
      });

      // Use event delegation for weekday names
      calendarContainer.addEventListener('click', (event) => {
          const dayNameElement = event.target.closest('.day-name');

          if (dayNameElement && isSelectingDate) {
              // Save as a weekly task
              // Get the index of the clicked day name
              const dayNameElements = calendarContainer.querySelectorAll('.day-name');
              let weekdayIndex = -1;
              dayNameElements.forEach((element, index) => {
                  if (element === dayNameElement) {
                      weekdayIndex = index;
                  }
              });

              if (weekdayIndex !== -1) {
                   // Store the date the task was added as the start date for the weekly task
                  const addedDate = new Date();

                  const newTask = {
                    description: taskDescriptionToSave,
                    type: 'weekly',
                    dayOfWeek: weekdayIndex,
                    date: addedDate.toISOString() // Store the date added
                  };

                  tasks.push(newTask);
                  saveCalendarTasks(); // Save and regenerate calendar

                  // Keep selection mode active, do NOT reset state or UI here
                  // Add feedback to the weekday name - apply class directly to the clicked element before regeneration
                   dayNameElement.classList.add('task-added-feedback'); // Add a class for temporary feedback
                    setTimeout(() => {
                         // Need to find the updated element after regeneration
                         const updatedDayNameElement = calendarContainer.querySelectorAll('.day-name')[weekdayIndex];
                         if (updatedDayNameElement) {
                             updatedDayNameElement.classList.remove('task-added-feedback');
                         }
                    }, 500); // Remove class after 500ms

                  alert('Weekly task added for ' + dayNames[weekdayIndex] + '!'); // Optional feedback
              }
          }
      });

      // Use event delegation for the Open Add Task Modal button
      calendarContainer.addEventListener('click', (event) => {
          const openModalButtonInsideCalendar = event.target.closest('#openAddTaskModal');
          if (openModalButtonInsideCalendar) {
               if (modal) modal.style.display = "block";
          }
      });

      // Add hover effects for weekday names using event delegation
      calendarContainer.addEventListener('mouseover', (event) => {
          const dayNameElement = event.target.closest('.day-name');

          if (dayNameElement) {
              // Get the index of the hovered day name
              const dayNameElements = calendarContainer.querySelectorAll('.day-name');
              let hoveredWeekdayIndex = -1;
              dayNameElements.forEach((element, index) => {
                  if (element === dayNameElement) {
                      hoveredWeekdayIndex = index;
                  }
              });

              if (hoveredWeekdayIndex !== -1) {
                  // Highlight all calendar days of this weekday
                  const calendarDays = calendarContainer.querySelectorAll('.calendar-day:not(.empty-day)');
                  const year = parseInt(calendarContainer.querySelector('h2').textContent.split(' ')[1]);
                  const monthName = calendarContainer.querySelector('h2').textContent.split(' ')[0];
                  const month = monthNames.indexOf(monthName);
                  const firstDayOfMonth = new Date(year, month, 1);
                  const startingDayOfWeek = firstDayOfMonth.getDay();

                  calendarDays.forEach((dayElement, index) => {
                       // Calculate the day of the week for this calendar day element
                       // The index in the NodeList is 0-based relative to non-empty days
                       // Need to adjust for the starting day of the week
                       const dayOfMonth = parseInt(dayElement.textContent);
                       const dateForDay = new Date(year, month, dayOfMonth);
                       const dayOfWeekForDay = dateForDay.getDay();

                       if (dayOfWeekForDay === hoveredWeekdayIndex) {
                           dayElement.classList.add('weekday-highlight');
                       }
                  });
              }
          }
      });

       calendarContainer.addEventListener('mouseout', (event) => {
          const dayNameElement = event.target.closest('.day-name');

          // Only remove highlighting if the mouse is leaving a day name element
          // This prevents removing highlight when moving from day name to a highlighted day
          if (dayNameElement) {
               // Remove highlighting from all previously highlighted days
              document.querySelectorAll('.calendar-day.weekday-highlight').forEach(element => {
                  element.classList.remove('weekday-highlight');
              });
          }
      });

    }

    // Function to explicitly enter selection mode
    function enterSelectionMode() {
        isSelectingDate = true;
        // Apply selection mode class to container for CSS highlighting
        calendarContainer.classList.add('selection-mode');
         // Show the done button
         if (doneSelectingButton) doneSelectingButton.style.display = 'block';

    }

     // Function to explicitly exit selection mode
    function exitSelectionMode() {
        isSelectingDate = false;
        taskDescriptionToSave = ''; // Clear the stored description
        // Remove selection mode class from container
        calendarContainer.classList.remove('selection-mode');
        // Hide the button
        if (doneSelectingButton) doneSelectingButton.style.display = 'none';
    }

    // Update DOMContentLoaded listener
    document.addEventListener('DOMContentLoaded', () => {
        // Get element references after DOM is ready and assign to global variables
        modal = document.getElementById('addTaskModal');
        // openModalButton = document.getElementById('openAddTaskModal'); // No longer get here
        closeButton = modal ? modal.querySelector('.close') : null;
        doneSelectingButton = document.getElementById('doneSelectingButton');
        taskDescriptionInput = document.getElementById('taskDescription');

        // Generate calendar after loading tasks - this call will now also add event listeners
        loadCalendarTasks();

        // Assign event listeners for static elements (openModalButton listener moved to addCalendarEventListeners)
        // if (openModalButton) {
        //     openModalButton.onclick = function() {
        //       if (modal) modal.style.display = "block";
        //     }
        // }

        if (closeButton) {
            closeButton.onclick = function() {
              if (modal) modal.style.display = "none";
            }
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
          if (modal && event.target == modal) {
            modal.style.display = "none";
          }
        }

        // Add event listener for the Done Selecting button
        // Ensure this is assigned only once
        if (doneSelectingButton && !doneSelectingButton._listenerAttached) {
            doneSelectingButton.addEventListener('click', () => {
                exitSelectionMode(); // Call the exit function
            });
             doneSelectingButton._listenerAttached = true; // Mark listener as attached
        }

        // Assign form submit listener here after modal and input are assigned
        const addTaskForm = document.getElementById('addTaskForm');
         if (addTaskForm) {
            addTaskForm.addEventListener('submit', (event) => {
              event.preventDefault(); // Prevent default form submission

              // Use the globally assigned taskDescriptionInput
              const taskDescription = taskDescriptionInput.value.trim();

              if (taskDescription !== '') {
                taskDescriptionToSave = taskDescription; // Store description temporarily
                if (modal) modal.style.display = "none"; // Close modal
                enterSelectionMode(); // Enter selection mode

                // Clear the input field - use the globally assigned variable
                if (taskDescriptionInput) taskDescriptionInput.value = '';

              } else {
                alert('Please enter a task description.');
              }
            });
        }
    });

    // Function to save tasks to localStorage
    function saveCalendarTasks() {
      localStorage.setItem('calendarTasks', JSON.stringify(tasks));
      // After saving, regenerate the calendar to show the new task indicators
      generateCalendar(); // generateCalendar now calls addCalendarEventListeners
    }

    // Function to load tasks (placeholder - displaying on calendar is next)
    function loadCalendarTasks() {
        tasks = JSON.parse(localStorage.getItem('calendarTasks')) || [];
        // Logic to display tasks on the calendar will go here later
        generateCalendar(); // Generate calendar after loading tasks, which calls addCalendarEventListeners
    }

  </script>

</body>
</html>
